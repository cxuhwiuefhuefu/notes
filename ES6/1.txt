<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
    <script>

        // ES6
        //    ES3 ES5我们都学了 ES指的是什么 为什么要出这个东西 
        //    ES6对应着我们的JavaScript JavaScript是哪年被发明的 1995年 刚开始干什么呢 因为那个时候已经有服务器了 原来之前这个浏览器相对于文本查看器一样
        //        就是它主要用来显示一些文字信息的 文字内容的 更多的交互是没有的 也没有轮播图 最早浏览器图片都不能显示 只能显示文字
        //        主要负责表单验证 在08年之前如果玩个游戏会有验证 有个输入框 用户名密码 确定 提交 就是获取里面的内容把信息提交到服务器 如果发现用户名不对再返回回来
        //        没有按验证这一步 这个JavaScript它的出现刚开始就是为了表单验证 有它之后就开始我们前端的发展 原来没有前端这个职业的 只有后端 前端 服务器都是它做的
        //        为什么呢 因为之前前端没什么东西 要么做不了 要么做不好 那个时候规范也没有定 能做的事情也少 随着我们后来JavaScript引擎渲染引擎的的加速 
        //        html4.0 css2.0的出现 加上渲染引擎使得我们这个网页更多元化 能动起来 包括Ajax的到来使得我们前端单独被分出来了 
        //        分出来是因为我们浏览器能做的事情越来越多了 人对交互的要求越来越高 我们要实现的功能越来越多 这样的话对我们来说工程量任务量要大的 
        //        于是在后端把前端分离出来了 前后端分离 之前不叫JavaScript 叫LiveScript 为什么叫JavaScript 蹭Java的热度 
        //        1996年分布JavaScript1.0版本以及1.1版本 当时对浏览器特别好用的脚本语言 在97年存在三家公司实现了脚本语言的三足鼎立的状态
        //        网景公司产生的JavaScript 微软产生了JScript(因为版权问题叫这个名字) 在IE3浏览器中实现了JScript对这个脚本语言的注入
        //        Nombas产生了ScripteEase 三家意味着有三种对应的脚本浏览器语言 如果我想开发一套页面 没有样式 纯是操作我们页面中的某个元素 
        //        刚开始内容也是不多 如果开发一套网页的话需要需要三套人员进行维护 因为你不知道要打到那个浏览器上面去 
        //        你不知道这个脚本会在哪个浏览器上会有什么样的表现 也许不执行 也许会报错 那这样的话 要么累死人 要么开发成本极高 你三个人维护一个页面 
        //        于是就被上述了  ECMA这个组织 欧洲计算机制造商协会 比较有分量 以JavaScript1.1为蓝本 作为基础版本来制定了在12月份发布了ECMAScript1.0版本
        //        制定了这样的浏览器语言规范 当时window这个操作系统很受欢迎 window上自带IE浏览器 而且有些浏览器是捆绑销售的 就是你这个系统带这个
        //        这样的话就导致IE市场份额比较大 来开会的时候 IE毕竟是老大规范我们可以一致 但是API我自己设置 
        //        所以大家就会发现兼容性的问题百分之百有IE 可能其他浏览器有差异 是引擎的问题 但是基本的我们的API是一样的 微软自己搞了一套 
        //        现在逐渐规范化当中 为了向后兼容 历史遗留问题还保留至今 1999年HTML4.0分布 奠定异步传输的基础叫Ajax Ajax不是1999年产出的 
        //        但是在1999年微软首次提出异步传输解决的方案
        //        定义了一个API ActiveX 创建Ajax用兼容性版本的时候通过它 还有一个正经的Ajax对象 异步传输对象 XMLHttpRequest
        //        它的到来可以实现我们可以异步处理页面 这个时候已经进入WEB2.0时代 因为之前浏览器是为了展示文字的 就是我看文档 通过万维网进行传输 
        //        为什么IE现在跟我们能兼容的就兼容呢 在2008年 Chrome横空出世 带来了极速JS引擎 代号V8 我们node当中也用到它 
        //        使得我们页面这个JS执行效率非常非常的高 意味着对JS认可性非常大了 意味着JavaScript做的事情也非常多了
        //        这个时候它的出现执行速度各个方面都比IE快很多 IE直接就输了 这个是JavaScript大的转折点 
        //        之后HTML5 CSS3的出现配合着谷歌浏览器让我们的页面多样性化 能做的事情更多 给我们的用户体验越来越好 所以说在这真是我们JavaScript转折点
        //        JS不断得到重视 不断推出新的规范 这个17年分布了1.0 08年已经在商量要推出3版本 到09年已经推出了这个ES5 但是在分布ES4的时候出了点问题
        //        为什么出了点问题 网景brower ich还是有先见之明 在ES4推出的时候它有添加clas类继承模块...   这样的一些功能都提出来了 作为草案提上去了
        //        但是理事会认为你一个浏览器的辅助浏览器的脚本语言平台性极差 只能在浏览器中跑就没太当回事 就选一些新的方法放到新的版本 叫ES3.1版本
        //        ES3.1最终形成我们这个ES5这个版本 有些数组新添加的方法 ES4有3.1还剩下一部分 放到ES6当中 ES5是09年分布的 ES6中途发生很大的变化 
        //        15年才分布ES6 1.0版本 我们在学webpack要配置ES2015这个 ES6比较特殊     -----   这个是JavaScript的相关发展
        //    
        //
        // ES是ECMAScript ECMAScript为什么不叫JavaScript 因为版权问题 虽然说用JavaScript1.0这个版本作为规范提供了一些支持 
        //     但是对应这个组织它是制定规范的 JavaScript当时已经被网景公司注册了 因为这个规范是这个组织定义的 以ECMA命名称之为ECMAScript
        //     哪个版本后面加上版本号 ES3 ESMAScript3 ES5 ESMAScript5  ECMAScript与JavaScript是什么关系 ECMA这个组织是制定规范的 
        //     那么这个JavaScript是浏览器对这个规范的实现 就是ECMA告诉浏览器你要有什么样的功能 具体的API由浏览器底层去实现 
        //     那这个JavaScript对应浏览器底层 对应技术API的实现 有时候说JavaScript和ECMAScript是相同的 其实在广泛意义上说是可以的 
        //     但是ECMAScript是规范 JavaScript对这个规范的实现 是具体的API     
        //
        //
        // 新的语言规范出来了 ES3 ES5 ES6 每次推出一些规范我们遵循这个规范 但是按照什么原则去遵循呢 包括每个规范里面它对原来有什么影响吗 不是推陈出新
        //     用新的规范而不用旧的规范 对于新规范假如的原则是这样的 对于原来有的东西我们要继续保留下去 因为这样我们不需要大面积的进行重构
        //     采用向前兼容机制 把原来的东西还留着 原来的代码还能跑 废弃一些不友好的API 比如with/eval 因为它能改变作用域 对我们的影响还是比较大的 
        //     能不用尽量不用 所以这种API在逐渐的废弃 既来之则安之 和原来的API共同使用 根据你的知识程度去使用
        //
        //
        // ------  1. JavaScript发展史 2. ECMAScript和JavaScript的区别 3. 当出现新的规范怎么办
        //
    
    </script>

</body>
</html>


//***********************************************************************************************************

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
    <script>

        // 块级作用域
        // 什么是作用域 由于代码执行会产生代码执行的空间 这个空间就是我们所说的作用域 域代表着一个空间/一块 作用代表变量或者函数可以作用的范围 
        //     就称之为作用域 多个作用域放到一起嵌套关系形成了作用域链
        // 在ES6之前有  全局作用域 window      函数作用域: 由于函数执行产生的作用域被称为函数作用域

        // var a = 10;
        // function person() {
        //     var name = 'dxb';
        //     var age = 18;   
        // }   
        // person(); // 执行完就把person里面的作用域释放了



        // 闭包是什么 就是由于在函数外部返回本应该被释放掉的内存形成的一种现象就是闭包

        // function Person() {
        //     var name = 'dyz';
        //     return function() {
        //         console.log(name);
        //     }
        // }
        // // scope2 --> scope1 name  -->  global
        // var fn = Person();
        // fn();


      
        // if(false) {
        //     var a = 10;
        // }else{
        //     console.log(a);
        // }



        // for(var i = 0; i < 1; i++) {

        // }
        // console.log(i) 



        // var num = 100;
        // // 100行代码
        // var num = 0;
        // var弊端: 变量重复定义 污染同一作用域下的作用域 作用域混乱 
        //      块级作用域的出现解决了这个弊端
        // 我们要定义的变量不要在当前定义 把所有变量都放在上面 也可以很好避免这个问题



        // 块级作用域的形式: 只要在大括号{}都可以称为块级作用域      定义的变量  函数  if else  for  function
        // 块级作用域的特点: 在这个块级作用域里面定义的变量 它作用域只会在当前的作用域下有效 以及它的子作用域

        // {
        //     var msg = 'welcome 2 duyi';
        //     {
        //     }
        // }
        // console.log(msg);

        // let && const
        // {
        //     let i = 10;
        // }
        // console.log(i); 
        // 通过let声明的变量具有识别块级作用域的能力 这个块级作用域原来就有 但是通过var来声明的变量不认识它 它只认识window和函数作用域
        


        // {
        //     let a = 10;
        //     var b = 10;
        //     {
        //         let c = 10;
        //         console.log(a);
        //     }
        //     // console.log(c);
        // }
        // console.log(b);
        // console.log(a);



        // 通过var声明的变量可以反复声明 但是let不允许
        // let p = 'dxb';
        // let p = 'dxb';



        // 之前存在var变量提升 提到作用域的顶端   let没有变量提升
        // console.log(a);
        // a = 10;
        // var a; 

        // console.log(name);
        // let name = 10;

        // typeof按键操作 哪怕你这个值未定义也不会报错
        // 暂时性死区 (TDZ temporal dead zone) 发生在预编译阶段的
        // 为什么会报这个错呢 在之前预编译的时候遇到函数函数声明整体提升 遇到变量变量声明提升
        // 暂时性死区是干什么的 当JavaScript引擎在这个扫描代码的时候 也就是预编译 扫描代码的时候干什么呢 分两种情况 如果你通过var声明的
        //     变量声明整体提升 你通过let声明的变量 let a = 1; 把a放到TDZ当中 当我在执行的时候如果使用的变量在TDZ当中就会报错 那怎么把它拿出来呢
        //     当我们执行到声明那一步let a = 1;执行这句话的时候它就会/在遇到声明变量的那段代码的时候 let a时候它会把a从TDZ中拿出 
        //     你下次再使用它的时候就不报错了  ------ 一定要先定义后使用
        // typeof name;
        // let name = 10;

        

        // let x = x; // 为什么会报错 第一步初始化TDZ 有x 第二部你遇到了let x = x; 什么叫什么变量 当这个变量被赋值成功的时候才能叫这个let完成
                   //     第二部先用x值 它先用这个x值赋值 所以它用的是右边的x给左边的x赋值 先用的后声明 所以这个TDZ中还是有z的 所以这个时候会报错
                   //     先用右边的x 再声明左边的x 所以会报错


        // 为什么报错 这个暂时性死区是统领当前作用域 什么叫统领 我这个作用域内用这个x是不是我扫描这个块的时候我上面是不是有个TDZ
        //     当你用这个x会不会到外面找x 在当前作用域下你还声明了x 那这个x一定还在TDZ当中 它也不会去外面找 所以说这报错           
        // let x = 10;
        // {
        //     let x = x;
        // }           


        // 如果在同一作用域下会报错 如果不在同一作用域下就不会报错了  不报错说明这三个let不在同一作用域内
        // let i = 'window';
        // for(let i = 0; i < 10; i++) {
        //     let i; // let i = i;
        //     console.log('scope2');
        // }
        // console.log(i);


        // let i  = 'window'; // window
        // {
        //     let i = 0;
        //     while(i++ < 10) 
        //     {
        //         let i;
        //         console.log('scope2');
        //     }
        // }
        // console.log(i);





        // var arr = [];
        // for(var i = 0; i < 10; i++) {
        //     arr[i] = function() {
        //         console.log(i);
        //     }
        // }    
        // console.log(i);
        // arr[6]();

        // var arr = [];
        // for(var i = 0; i < 10; i++) {
        //     arr[i] = (function(j) {
        //         return function() {
        //             console.log(j);
        //         }
        //     })(i)
        // }
        // console.log(i);
        // arr[6](); 

        // 每次执行i的值都不一样 for循环执行完这个i应该被注销 因为外边没有这个i的 这个i应该被注销 因为它执行完了 所产生的块级作用域范围到 该凉了
        //     我们这个i能被访问是因为这个i值没有被删除而是存在内存当中 每个值还都不一样 导致它可以正常的去访问当中的每个值 它原理是闭包
        // Babel可以把ES6处理成我们原生的 通过let声明的变量是不会暴漏到全局的
        // var arr = [];
        // for(let i = 0; i < 10; i++) {
        //     arr[i] = function() {
        //            console.log(i);
        //     }
        // }
        // arr[6]();





        // const: 常量   const定义的值不能改变的 但是它真的不能变吗 一般常量习惯大写去表示常量
        //     用const定义的变量存的是地址 只要你地址不变 你加多少层不管 但是你地址要变了不行 常量地址不能变 当单个变量原始值的时候它就不能被变了
        //     因为你每次只要重新赋值的话都要重新申请一个地址 但是对象的话你在对象中随便添都无所谓 它也有暂时性死区  也不允许重复声明
        // const PI = 3.14;
        // PI = 3；

        // const OBJ = {};
        // OBJ.a = 123;

        // const di = {};
        // // di = {};
        // di.floor = 10;

        // const di = 10;
        // const di = 10;

        // console.log(di);
        // const di = 10;
        // const di = 10;


        // 通过Babel转的时候 let的性能不好 但是它给我们带来的安全性各方面有很多的优势 正如我们在开发的时候有一种建议我所有的变量都通过const进行声明    
        //     在开发通过const进行声明的变量尤其是一些常量的话是不变的 但是你想让它变的话可以改成let这种方式去声明 这样让我们的代码更坚固 
        //     因为let和const不允许重复命名 遇到重复声明会报错
        

    </script>

</body>
</html>