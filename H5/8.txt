<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>	
<body>

    <script>

        // video不是调用control才把组件调出来 组件每个浏览器长的都不一样 chrome有chrome的样子 IE有IE的样子 是各个浏览器实现的 它的样子一般都比较丑
        //     我们在开发的时候都不会用它默认的样式 都会自己写 它那个默认的样子你是调不了的 播放的进度条怎么写 可以点击/移动/拖拽吗 还有全屏展示 
        //     可以啊 我们在播放一个音乐的时候你不是可以点击拖拽那个视频的进度吗 拖拽那个视频的进度你就调整视频播放的时间就可以 
        //     currentTime能设置和返回当前播放的时间 当你拿这个鼠标拖动的时候 然后你就可以用这个currentTime设置当前的时间 比如说这个进度条 
        //     进度条有这么长 当前你这个播放了 当前播放到这 你拖拖 拖到这个地方 那你拖到这个地方的时候 如果我们自己写这个进度条样式的话
        //     你是不是要知道你中间的进度条拖到这的时候鼠标的位置是多少 鼠标的位置是多少是不是应该给宽度设置多少 
        //     你给这个宽度设置多少你再对比它占了整个父级宽度的百分之多少 你是不是能拿到一个百分比  是不是拿到当前这个歌曲相对于总时间的百分比
        //     比如说这个歌曲或者视频时长是1分钟 然后你鼠标挪到这个位置正好挪到中间 那这块你把它的宽度 这个宽度是100 整个宽度都是200 
        //     那你把它的宽度设置上100 设置上100之后 那它是100 外边这个父级不是200吗 那它占百分之五十 
        //     那这个视频或者是音频它播放的时间正好播放到百分之五十的位置 百分之五十你再获取一下总水平的时长乘以百分之五十 
        //     不就能设置当前这个播放到哪个点上了
        //
        // 音乐播放器后期有项目 会用构建工具
        //
        //
        //
        // SVG也是做图形的 它跟canvas的区别 canvas它是就是一个画布 你创建一个dom元素 你在这个dom元素上进行操作 然后SVG它是一个一个dom元素 
        //     一条线代表一个元素 一个样的什么东西代表一个元素 它是由多个dom元素组成 所以当你看你现在做动画的场景是什么  
        //     如果你这个动画的场景它设计的动画非常多 然后就这个图形里面的内容非常多 这个时候你就不要用这个SVG 最好用canvas 因为canvas只是一个dom元素
        //     它通过js操作是一个dom元素里面的东西 而你这个SVG是让它进行动画或者 如果说它是一个静态图形 首先SVG的标签就很多 加载就会比较慢 
        //     再它是一个动画你用js操作dom/操作这个标签的时候 它们这个标签一运动就会引起页面的重排重绘 然后动画就会缓慢 所以说你做动画的时候你用canvas 
        //     包括canvas做一些游戏里面的场景都是用canvas来做的 不是用SVG来做的 SVG做动画最重要的一个地方在这个地方 
        //     它要结合stroke-dashoffset做一个动画
        //
        //
        //
        // 地图怎么用 一般用百度的地图 取百度的API看看 做的时候不要直接拿过来就看文档 你先做出来它给出来的示例 做出个小demo 再细看每个文档是看嘛的
        //     这里明确标识 回去读一读文档 
        //
        // 数据可视化可能会用到echart
        //
        //
        //
        // requestAnimationFrame是H5用来做动画的 我们现在做动画可以用计时器来做 还可以用CSS3来做 再可以用requestAnimationFrame来做
        //     然后requestAnimationFrame它的好处 它相对于计时器的好处是什么 相当于计时器而言它比较准确 帧数比较准确 因为计时器
        //     我们主线程在这执行的时候 如果你设置了一个计时器那么它会在这个地方 比如你设置多长时间之后它会在这个地方开启这样的线程 
        //     然后这块是你那个计时器  比如你设置一分钟之后 比如10秒之后再执行 那在这等啊等 10秒之后 这个事件是不是应该执行了 
        //     那这个事件执行的时候是不是插入到这边来 但它插入到这边来合并到主线程过程是由主线程主动向这边请求的 
        //     主线程向这边请求一次然后把数据拿过来让它在这执行 主线程主动向这边请求就会存在一个问题 
        //     如果说你在这设置一个计时器 上这边等待去那这边你中间有个操作 而这个操作它操作20秒钟 那它操作20秒直到操作完成主线程才空闲下来 
        //     那主线程空闲下来是不是才能上这边看看是不是有事件要执行 那这个时候它才看还有个东西要执行 它已经在这等着了快把它拿过来再执行 
        //     那这个时候已经晚了10秒钟了 所以我们看到画面就会有一些掉帧或者是卡顿的现象 掉帧是因为什么 掉帧是因为我们把那个计时器的时间设置的太小了
        //     屏幕刷新的频率是16毫秒 如果你让计时器设置动画的时间每隔8秒钟运动一次 比如它每次运动10像素 8秒钟的话从0变到10像素了 但是页面不刷新 
        //     你看不到它挪出来10像素的效果 然后再过8秒又挪了10像素 又是20像素 20像素的时候正好是两个8秒 16毫秒 16毫秒这里浏览器大概刷新了一次 
        //     这个时候它会突然从0跳到了20 会出现掉帧的情况 如果再就是requestAnimationFrame相对于CSS3动画有什么特点 我们现在用CSS做动画是不是很流畅
        //     它是不是比用transfer当中translate-3d/scale-3d的话  能开启GPU加速   那requestAnimationFrame相对于CSS3有什么优点吗 CSS3不是已经很好吗 
        //     相对于CSS3有什么优点  CSS3会开启GPU加速使动画更流畅 然后requestAnimation相对于CSS3优点是兼容方面的处理 
        //     CSS3它只在IE8以上的浏览器当中才能执行那些动画的效果 那些属性才好使用 那如果说在IE8以下的浏览器要做同样的动画是不是只能用计时器来做 
        //     那这个时候是不是用写两台方案 第一套IE8以上用CSS3来做 然后IE8以下是不是需要用计时器来 这样是不是写两套 然后requestAnimationFrame相当于setTimout 
        //     这个时候它虽然不是支持所以浏览器的 也是有限制的 低版本浏览器能优雅降级到setTimeout 高版本浏览器中用requestAnimationFrame就可以了
        //     它不是跟setTimeout的用法是相同的吗 只不过setTime这块有两个参数 你设置一个回调函数 你设置一个时间 requestAnimationFrame不需要设置时间
        //     只需来个回调函数就行 他们写一套就行了 所以方便兼容 就看一下你这个项目要求兼容的情况是什么样子的 
        //
        //
        //
        // 再一个是客户端存储也很重要 客户端存储主要有storage和cookie storage分两个临时存储和永久存储 localStorage永久存储 sesseionStorage临时存储
        //     他们有些文档源的限制 还有些窗口的限制  cookie可以在你浏览器上面设置一些存储 但是cookie主要不是用来存储数据的 
        //     像localStorage它的容量比较大 它是以兆为单位 它能存很多值 但是cookie它的值存储量少 只是以k为单位 差了一个量级的 
        //     所以cookie因为它的主要用途是标识用户 所以说在cookie当中你存的值也不是存了一些数组等等一些东西 它存的就是一些标识 
        //     比如存id/number等等这样的东西 所以它的用途就不固定了 所以它存储量很小的  你要他们的区别记住 因为面试的时候会考到这些问题
        //     尤其是cookie每次随着HTTP协议每次来回传输的 像storage什么时候用 比如说你打开一个页面 这个页面当中有一个视频
        //     你上一次看了这个视频看到1分钟的位置上 你现在关了 下次你再打开的时候它希望你从上一次看的位置上接着看 这个要怎么做 
        //     你想你这个窗口已经关闭 你再打开的时候它还希望你从上一次看的那个地方接着看 那这个怎么办 你是不是要把一些值存到这个浏览器里去 
        //     一旦你窗口一旦断开 你里面设置的那些变量是不是全部清空 你再重新打开那js重新跑了一遍 你里面的变量是不是全部初始化了一下 
        //     你要想拿到你上一次看到的那个时间 你只能在关闭窗口之前把那个变量存起来 存到哪里 可以存到cookie当中 也可以存到localStorage里边
        //     建议存到localStorage里边 因为cookie的用途主要是标识用户信息的 然后像这些变量值最好都存到storage里边 
        //     所以这个时候你存到localStrorage里边 不能存sessionStorage 不然人家一关闭再打开你就找不着了 像在公司开发的时候很常用 
        //     像标识基本上是用storage来做的 然后是history history.back()后退  history.forward()前进 history.go()具体到哪一页 它是一个历史记录栈
        //     用history可以实现Ajax前进与后退的项目 就正常来说的话 比如说我在这里访问了一个页面  一个页面能实现前进和回退吗  
        //     一直在这个页面当中也不往别的页面里进 那是不是历史记录是不是只有index.html一条记录  那现在呢 这里边有几个内容 
        //     你点击它的时候可以发送Ajax请求获取一个数据 点击它的时候也可以获取一个数据 那现在我想干嘛 我想回退到我刚才看的内容  比如内容比较多 
        //     你想回退一个一个比较来看 上一次看的是什么东西 那这个时候如果是一个页面 你是不是回退不回去了 一个页面回退不回去 
        //     只是单纯的用Ajax来做的话你点击它发送一个Ajax 你点击它发送一个Ajax Ajax能帮你把这个记录放到历史记录当中吗?? 不能吧 
        //     比如这块你在这搜索ad 现在你删除你搜索aa 是不是ad对应一个下拉菜单  aa对应一个下拉菜单 你回退一下能回退到ad那块的下来菜单里吗  不能 
        //     你在这获取一个数据再回退一下肯定不能回退到上一次你获取Ajax的那个数据 那这块时候可以结合历史记录来做 历史记录当中有这么几个值 
        //     一个是pushState(可以在历史记录当中添加一条历史纪录))/replaceState(可以给当前的这个历史记录替换一条) 原来你这个历史是A 
        //     现在把这个历史记录A给你换了 换成B 一个是替换 一个是添加  state: 这个是传一个状态 比如你在历史记录添加一个值的时候 
        //     你可以给历史记录传一个参数 把一些对象的状态传进去 当你再一次翻到历史记录的时候 它能把这个状态获取到 比如现在历史记录你有这么3条 123
        //     然后你插入第三条的时候你在里边传一个当前页面的一些状态值  然后当你翻翻再翻到这个第三个历史记录的时候可以把这个值取出来 
        //     单页面应用就是一个页面的 不适合大型的项目 像淘宝 像百度这个内容比较多 每个都是一个页面 像大型项目的话不适合单页面应用了 
        //     我们自己做的小首页就可以用单页面应用来写 
        //
        //
        //
        // Worker现在公司用到的不是很多 基本没有用到它 了解就行  worker是创建一个线程的 就像你雇佣了一个工人但前提是必须同源 创建一个线程 worker就是
        //     js不是一个线程的吗 你可以创建一个线程让它处理一些复杂的数据的操作 一些数学计算等等给它操作 让他操作完成给你返回一个值 
        //     把它操作结果给你 高斯模糊用worker来处理 因为高斯模糊它处理的是每一点的像素的值 我们写一个500 500大小的canvas的像我们当时做的是canvas
        //     用高斯模糊处理
        //     怎么处理来着 不是取那个canvas当中的每一个像素信息值 每一个像素信息值都是rgba来组成 所以每一个像素是由四个值 500*500*4 你要处理一百万个信息值 
        //     一百万个信息值处理起来比较耗时了 这个时候你就可以把它交给这个worker来处理 那你就创建一个worker  那这个函数你就写那个高斯函数 
        //     高斯函数你把这个对象传进来 传完之后他能给你返回出来 返回出来你把这个处理好的数据一传回去就可以了 它处理的数据量比较大 它不能处理dom操作 
        //     因为worker只是window的一个子集 它不能获取到window对象 也没有document对象 所以jQuery/zepto都不能用 
        //     jQuery它获取dom元素不是根据document来获取的吗 这个Ajax 计时器都可以操作的 
        //
        //
        //
        // geolocation获取地理位置信息 devicemotion获取加速度的 deviceorientation获取方向的 看你用的是什么浏览器 如果是chrome得翻墙一下 
        //     如果是IE就不用翻墙了 因为chrome的数据不在国内 watchPosition()监听位置变化的
        //     当我们这个位置变化的时候会触发这个watchPosition() 但实际上测试的时候哪怕你把手机放在这不动其实也是会一直触发watchPosition()的  
        //     这个时候它会一直监听你这个变化 然后这个监听地理位置信息不需要无时无刻的取获取 可以给它来个时间 我每个5秒更新一个数据/或者每个几秒更新一下数据
        //     maximumAge这块可以设置这个时间 如果超出这个时间这个位置信息重新更新一下用户的地理位置信息 在这个时间内不去获取 这个watchPosition()是一直会触发的
        //     默认情况下这个时间是0 清除跟计时器一样 把id往这一添就清除了
        //
        //
        //
        // 把文件放到wampserve下 然后手机电脑连接同一局域网 看一下你当前局域网IPV4地址是多少 手机把localhost换成IPV4地址 这个就是你当前服务器的地址
        //     手机访问就可以了 你们访问的时候有可能返回403  网上搜索就好 一定改好 改不好你整个wampserve都启动不了还不知道哪改错了
        //     最后把防火墙关了 网络分两种情况 一个是专用网络 
        //     一个是公共网络 公共网络里边会有些限制  最好把你的公共网络改为专用网络  不能远程访问 如果要远程访问要把你的代码传到服务器里边去了  
        //     当前我们用的服务器是我们电脑安装的吗 正常的不是一个大的机箱吗 如果你想传到属于自己的服务器里边的话 可以去百度云/腾讯云买一小块服务器
        //     如果不想花钱的话你就传到github上  GitHub
        //    
        // 
        //
        // 学习不要只局限于视频 公司要一个人更看中的是一个人的学习能力  因为前端技术更新换代很快 就像 按框架 大概react很火  现在vue很火
        //     vue刚开始出来肯定没有这个视频教你怎么用 那怎么办 只能看文档 网上找资料学习  遇到问题主动的搜索一些知识
        //     当你工作之后发现有些人解决问题的能力特别强
        //     有些人解决问题的努力很弱 有的人知道这个问题出现应该怎么办 去哪个地方搜索 比如同样是百度 有可能你的leader百度的比你找到解决问题的办法要快 
        //     因为他平时都上网去找一些类似的问题  一些类似的问题他知道什么样的网站能回答 什么样的网站回答的准确率更高 什么样的相对应的文档看起来是真实的
        //     什么样的看起来是假的 什么样的自己写的 什么样的是官方的 这跟他们自己平时上网上找一些资料/解决一些问题 平时积累这些东西有关
        //     获取主动学习的能力
        //
        //
        //
        // 加速度看你手机是否在运动的状态 其实可以用它做走路计步那个 我们现在计步的不是页面的 我们现在要用它的话做浏览器端页面这样的计步 
        //     手机端这样的都是基于安卓/IOS开发 这样用js写不了 用H5也写不了 H5只能写页面端的开发 就按微信摇一摇来看 大于这个值可以测出用户在摇动
        //     可以把这个值调小点 可以判断用户在走 比如说用户每动一次值+1
        //
        //
        // deviceorientation是监听方向上的变化 可以判断你手机当前是什么样的位置 比如说 去年双11 手机用户 
        //     当你手机屏幕往下趴的时候这个页面看起来有动画的效果 就有种像VR的效果  当你手机扬起来又会有种效果 这个监听你设备上方向的变化了 
        //     比如你手机往下趴 可以让里面的元素沿着Z往前走走  手机往后仰可以让元素沿着Z轴往回走走 这样感觉往前趴会变大 往后仰会变小 
        //     往前走多少取决你手机的角度 可以获取沿X轴旋转的 再一个可以获取指南针 再一个页面端可以获取方位的 
        //     就是浏览器端获取这个方位的它要依赖于我们设备 但是IOS相对来说还是比较准 但是安卓相对来说没那么准确了 安卓没那么准确了 
        //     安卓只能通过获取这个值获取这个alpha角度 但很遗憾alpha不精准 所以安卓现在也没有很精准的方法能够获取到北东西这些值 
        //     但是你可以做着玩试试 你换成alpha也能让盘转 只不过不太准 这个公司开发中用的不是很多
        // 
        //
        //
        // drag/drop 拖拽你做个小游戏改变一下顺序 再一个你用它拖着东西上传 这个上传文件 你拖拽一个文件进行上传并不是你拖进来人家主动帮你上传了
        //     人家得帮你操作 操作的话就要涉及一个读取上传这两步 那读取的话用FileReader的方式来读取 这个比较常用了 
        //     公司开发中一般你做一个像一个电商的购物平台的话 那么一定会有两个界面 一个是给用户看的 
        //     比如说你这里有商品那我是不是看一下这个商品卖这个邓哥 名称/年龄/个数你看这个邓哥的信息的时候它会些图片 有些名称 这些东西哪里来的 
        //     是不是那个就是卖家传上去的 所以商家往上传的时候商家这边也得有个界面把 我们是买家 买家跟商家看到的界面不一样把 
        //     商家是不是会有个管理的界面 他能通过这个管理的界面往上上传图片 添加商品的名称 添加视频的价格 这个时候你是不是要涉及图片的上传问题了
        //     onload读取成功之后会触发onload 这个时候我们就要把读取的结果拿过来 拿过来之后就上传给服务器 你可能会用到一个POST请求或者是PUT请求
        //     把这个数据给它传到服务器里边去 传的数据是什么 是这个this.result 
        //
        //
        //
        // 显示缩略图 这个拖拽到服务器可以实现预览的功能  这个预览的功能是这样的 你先把这个拿到它的URL 你拿到这个URL之后给这个src
        //     这个时候我们自己创建一个img标签把这个URL给这个src 然后把这个img展示出来了 这个方法是可以把刚才传进来的这个文件转成base64报名格式
        //     转成URL 这个时候给这个img 插入到body就能用了 
        //
        //
        //
        // 像微信里边经常看到一个页面 这些页面里边会有些视频 小视频什么的 像页面的小视频 腾讯其实有文档了 不过你也可以自己做的 你可以做一个小视频
        //     做完这个小视频你可以中间给它弄一个 自己做的话写这样一个页面 然后这个页面你写一个video标签 样式的话你自己决定自适应还是怎么着 
        //     然后就是你引入一个video之后 然后你放到手机里看的时候 它默认就会有这样一个进度条 然后你点开的话根据我们手机安卓或者IOS
        //     它那个样式还有点不相同 就跟你正常开发是一样的 你写一个video标签 然后这个video标签在你手机端展示的时候就有那个进度条了
        //     因为那个控件不是在各个浏览器都是不太一样吗 所以在移动端跟在PC端的时候那个控件也是不太一样 它还有个默认的暂停按钮 
        //     但那个按钮在安卓和IOS不太一样 你要想做到统一的话得需要自己画一个小图标了 自己拿一个小图片替换掉 再一个兼容性的问题 视频不都是有个封面吗
        //     视频和电脑是一样的 PC端怎么做 移动端就怎么做 移动端会有些兼容问题 然后这个post ios和安卓也不一样 安卓的post好使 IOS的post不好使
        //     最开始你看到的应该是黑的 不是post的问题 最开始的时候我们不给他设置post 你不设置post的话默认情况下是不是会看到视频的第一帧的那个画面 
        //     但是安卓和IOS不一样 IOS能看到第一帧的画面 但是安卓看不了  安卓看不了 它应该是黑色的效果 这个时候解决办法你自己截一个图
        //     截第一帧的画面把这个第一帧的画面用POST放上去 作为一个图放那 如果你没有POST 安卓可能看到这个视频是黑色的东西 
        //     所以这个时候你可以把视频第一帧截一下 截好一个图 开发的时候有很多这样的问题 想办法解决把 想有些小技巧 小窍门
        //
        //
        //
        // WebSocket现在暂时了解 现在开发的时候基本还是HTTP协议 没有用WebSocket协议的 大家了解一下就行 了解一下理论知识 了解一下这个长链接 
        //     再了解一个轮巡 比如说网页版的聊天  对方是怎么把数据给你的 你没去请求的话对方是不可能把数据给你的 这个就存在轮巡的问题 
        //     它在不断的去服务器请求数据 然后这个轮巡可以用WebSocket来做了 由服务器主动给你推 这个WebSocket的知识点没有实际的操作 
        //     现在你了解一下它的理论就行了
        //
        // 基本移动端视频进度条反而微信都用它默认的样式 它那个进度条默认拖到那个位置上它有时间不用往里设 默认情况下进度条拖到这时间不是自己跟着变 
        //     只有自己写才不会自己跟着变 你需要自己设置一下 你自己需要算一下
        //
        //
        //
        // echart: 数据可视化的东西 但这个比较简单 因为它文档给的很全 数据可视化东西是什么呢 可能用户看到的不是很多 但是在公司内部他们会
        //             大的公司一般会有个专门的部门 这个部门专门为公司里边做产品 就是公司里边这些部门做产品的 他们就会涉及数据可视化的东西
        //             因为把这些数据给各个报名呈现出来 以这种可视化的形式给他们出现出来 便于他们看这个数据   头像得是后台把数据给你的
        //             这个部门不需要做这种兼容性问题的 你们做好这个产品 因为是给公司内部看的 你要告诉它这个东西你要用这个浏览器来打开 
        //             这个兼容性的问题了 你要想用它这个东西的话得下它这个js 它这个东西实际上原理是什么东西 我们下载一个完整版的或者这个   
        //

    </script>
    
</body>
</html>

//************************************************************************************************************************************************************************

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>

        #box{
            width: 500px;
            height: 500px;
        }
    
    </style>
</head>
<body>

    <div id="box"></div>
    <script src="./echarts.min.js"></script>
    <script>

        var oBox = document.getElementById('box');

        var myChart = echarts.init(oBox); // 入口接受一个参数   
        var option = { // 如果你想用这些东西 必须配置完这些参数
            title: {
                text: 'ECharts 入门示例'
            },
            tooltip: {},
            legend: {
                data: ['销量']
            },
            xAxis: {
                data: ['衬衫', '羊毛衫', '雪纺衫', '裤子', '高跟鞋', '袜子'] // 一般会通过Ajax获取过来 因为后台给你数据 你要把这个数据给用户渲染出来
                                                                          //     让用户更方便直接的看出来 所以这些东西不可能是你提前写好的 
                                                                          //     肯定是后台传给你的 后面我们会把这些值动态的生成
            },
            yAxis: {},
            series: [{
                name: '销量',
                type: 'bar', // 柱状图
                data: [5, 20, 36, 10, 10, 20] // 一般会通过Ajax获取过来
            }]
        }

        myChart.setOption(option);

        


        // 你会发现里面会主动添加个div div里边是个canvas 那就是说它是用canvas进行绘制的 所以说它只有个js文件 canvas不就是通过js文件来操作的吗
        //     canvas这个宽根据怎么来呢 宽度实际上根据你设置的这个值width来的 它会对比一下 如果你传了这么多会给你均分的 算出合理的宽度是多少 
        //     所以这里边会处理很多东西  这里边的宽度是多少 都在它这里边的js写的 
        //
        // 这么多图形的话可能我们在开发的时候根本用不到 根本用不到引入这些全的echarts.js 是不是有点浪费 所以这个时候它允许你自己构建
        //     比如说你就想要柱状图 饼状图 折线图还有个散点图 那这个时候你可以把这几个选出来 它会主动帮你生成一个js文件 这个时候你用生成好的文件就行了
        //     那这里边你用不了其他图形了 我们现在就引过来正常使用就行  南丁格尔图有些js动画的效果  饼/字还有线都可以自己调整颜色的 
        //     还有上面的阴影都可以自己调整 具体在参数里设置
        //
        // 所有的参数都是通过option配置出来的
        //
        //
        // 实现u个红包  上下抖动 移动端页面 你红包在哪抖抖 提示你去点那个红包 CSS3动画就可以完美实现 基数次正向偶数次反向 然后调整它的translate 
        //     然后有次数限制加个次数就行
        //
        // 一般的时候你想把这个数据给用户呈现出来 这个数据都是异步获取的 异步获取的话我们就要给它动态的添加了 异步获取的话用Ajax就可以操作
        //
        //
        //
        // 这个它先去加载数据 加载数据按照从小到大给它排列出来了 数据就是数组 数组里边就是对象  你通过Ajax去获取 获取完数据后怎么办 
        //     是不是要改变option的值 改变option的值用getData的方式来处理的  我们拿到这个数据发现没有按照从小到大的顺序来排列
        //     如果你想让它从小到大的展示出来 那这个data[]参数是不是从小到大排列 你要把那个数组的对象从小到大排列一下 所以这块就要涉及排列的问题
        //     排列怎么排 用getData()改变这个参数 改变之前把它先排列一下 排列完之后再往里插 那这个时候我们要用到这个sort sort是数组的一个方法
        //     因为我们获取到的就是这个数组 所以sort可以进行排序 排序的时候还记得sort方法 里边可以传一个函数 函数有个a和b的参数 
        //     然后return出来这个a-b 获得从小到大的排列方式 或者b-a是从大到小的排列方式 还有个小圈在这转 这个小圈在这转也是个小组件 你调用一下就可以
        //     最开始我先让它在这转 因为开始的时候Ajax是要异步请求数据的 所以你先让这个小圈在这转 然后等你Ajax数据获取成功之后你再让这个小圈隐藏掉 
        //     一个是showLoading hideLoading 然后它下面还有事件 点击会把这个参数打印出来 那这个参数传回来就是当前数据对应的信息 包括它的颜色是什么
        //     还有它底下name值是什么 还有它这个data值是多少它都会给你传过来 然后这个时候你可以拿这个值进行其他操作 比如说这个柱状图你可以做好几条
        //     一组里有好几条 你点它的时候可以拿到对应的一小条是多少 然后你拿到这个值可以做饼图 饼图也可以传参数的 
        //     像这种饼图你就可以把值给它传到这里边来 数据可视化的东西 是百度的   是12年出来的雏形 之后不断变化
        //
        //
        //
        // npm install webpack@3 -g                             下载   -g(全局)
        // npm install webpack-dev-server@2 -g                  开启服务器 开启服务器要下载个
        // 版本更新 配置 插件会改变一下 思路不变
        //
        // 经验 学的项目优化 
        //

    </script>

</body>
</html>
