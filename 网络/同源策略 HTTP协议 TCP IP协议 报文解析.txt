<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <script>

        // https是在http下加入了一个SSL层,是http的一个安全版本,是加密了一些信息
        // https://www.baidu.com:443/
        // 协议      域名                   端口
        // http://www.w3cshcool.com.cn:80/
        // 在默认的情况下https的端口是443,默认情况下端口可以不写
        // http的默认端口是80,默认情况下可以不写
        // 端口一旦被占用了就冲突了,服务器就开不起来了
        // 不是默认端口,一旦端口改成别的例如:8080,端口一定要写

        // 同路径下的
        // http://localhost/ajax/index.html
        // http://localhost/ajax/getNews.php

        // 顶级域名分为两类  1.(.cn)按照国家   2.(.com)按照国际
        // 按中国:   .cn顶级域名
        //               .com二级域名(分了七个)
        // 按国际:   

        // 在我们中国其实默认的顶级域名后面有个.cn, 所以baidu.com是二级域名
        //         不是中国的这些地区的,没有注册好的顶级域名的话.com是顶级域名

        // 以前为什么需要www标记
        //      浏览器只能通过www来识别
        // 现在为什么还需要www标记
        //     1.尊重用户习惯   
        //     2.裸域名(不带www的域名)可以只能绑定DNS的 A记录(域名对应的IP地址) 不能绑定C的记录(别名)    www.baidu.com --> ip地址      (别名)baidu.com --> ip地址 
        //               有www的可以取别名,可以绑定别名,但是没有www的不能取别名,只能对应唯一的IP 
        //               为什么输入baidu.com可以访问到www.baidu.com是因为两个网址绑定在一起了
        //     3.裸域的cookie的作用域范围大
        // NDS解析出IP的过程:DNS客户端会获取我们当前这个域名 会向DNS服务器端检查报文 由DNS服务器根据这个域名解析出这个唯一的IP地址 
        //                                 DNS服务器会这个解析完的IP地址发送给DNS客户端 一旦浏览器收取到IP地址就可以向该IP地址定位 发送服务器http请求
        // DNS服务器是怎么把wwww.baidu.com解析出来一个IP地址呢:   倒着一步一步解析域名的  DNS服务器解析时呈树状图 --》 最上面是.com  baidu www  这三段就构成唯一的IP地址
        // 每个端口对应着不同的服务,端口写错依然拿不到你想要的数据
        // 即使和别名绑定同一IP地址也不同源
        // 不同源ajax拿不到数据
        //
        // TCP三次握手  http请求基于TCP协议的  三次握手和四次挥手都是在TCP协议下的
        //
        //  SYN包
        //  ack包  +1
        //             +1 
        //
        // 报文的形式    客户端 --》服务器
        //
        // FIN表示关闭链接    ACK表示响应过程
        //
        //
        // UDP协议容易丢包,不在乎  --》 实时视频 实时语音
        // 
        // 前端后端访问数据的时候 要有规范来书写
        //  我们给后台服务器发送的是请求 后端服务器给我们的是响应
        //
        //
        // 1.0 只能发送一个请求得到一个响应,此次链接断开,如果再想发送一个请求要重新建立链接,比较浪费资源  
        // 1.1:长连接,一段时间内保持通信,一段时间内协议不会断开,可以发送多个请求得到多个响应
        //  Content--Length: 请求的内容长度
        //  Cache-Control: 缓存
        //
        // 主体：传递数据的     行：请求方式 请求地址 请求协议
        // keep-live: 长链接
        // Referer: 流量统计的
        //
        // 3XXX：浏览器升级了
        // 
        // 304: 为了实现缓存的,会把重新定向到浏览器的缓存资源当中,去取浏览器的缓存资源
        //
        //  get和post区别：
        //       1.功能上区分： get主要拿到数据,得到数据   post主要是推数据     商品下架了:delete请求
        //       2.数据传递的位置不相同: get请求数据拼接到url后面的   post请求数据放在请求主体当中的      get请求如果把数据放在请求主体当中,这个数据发不出去,只能放在url后面 
        //       3.get的传递的数据长度受限制  post传递的数据也是受限制,只不过传递的数据比get请求多很多 
        //                     为什么长度限制这样呢？get:浏览器的问题 URL地址栏当中有长度的限制   
        //                                                           post:考虑到服务器的安全性,如果对请求来的数据没有长度的限制的话,如果恶意的攻击,
        //                                                                   频繁的大量的往服务器里传递数据的话会把服务器搞崩溃的
        //       4.POST比GET安全   post请求是把数据放在请求主体当中的,get请求是放在url后面的  get请求用户马上就可以看到了  POST请求起码要打开控制台才能看到的 
        //                                             安全只是相对的  所以不要用户名密码放在post请求当中,打开控制台就可以看到了
        // 301/302 临时重定向/永久重定向      304: 为了缓存的
        // 重定向分两种: 向这个地方发送请求,重新定向到另一个位置,另一个位置分两种 1.分配到浏览器的缓存中 2.分配其他的服务器上,重新向别的地方发送请求
        //                       304就符合第一种,它向浏览器缓存当中拿资源,符合重定向这个特点
        // 
        // 怎么判定资源的更新 etag last-Modified
        //        1.etag: 每个资源都会分配唯一的ID赋到etag字段上
        //                 第一次发送http请求会给一个响应报文,响应报文中就会有etag属性,etag属性包含该资源所对应的唯一标识,这个标识就代表这个资源
        //                 第二次请求同一资源的时候给你一个响应,会先判断服务器这边的资源是否有更新,会把上次响应的etag值拿过来给它发过去,在请求头当中
        //                        的if-None-Mathch给它发过去,服务器拿到if-None-Math的唯一标识的图片资源的ID,会跟服务器这边的资源进行对比,如果没有更新给你返回个304
        //                        直接去取浏览器的缓存，如果更新的话把资源和新的etag的值重新给你 ,返回200状态                  --》                请求当中就减少了传资源的过程
        //         2.下一次请求的时候if-Modified-Since和上次的last-Modefied的值发送给服务器,让它匹配一下修改时间,一样就没有修改资源; 不一样就修改了资源,它会把
        //                   新的资源返回给你      
        //
        //
        //
        // 我们给后台发送的数据在请求主体当中
        // 后台给我们的数据也在响应主体当中
        //
        // 头设置一些信息
        // 行 请求方式 请求地址 请求协议
        //
        // content-length: 传递的数据的长度
        // host: 主机名  是域名加上端口号不包含协议的
        // Origin: 你当前的请求的地址来自哪里
        // refere: 你从哪个页面访问过来的 用于流量统计的
        //
        // 403: 服务器禁止访问或者我们请求的方式有语法错误    404: 服务器没有找到资源
        //
        // Server: 服务器
        // data: 返回数据的时间
        //
        //
        // get请求数据超出就会截断
        //
        //max-age: 设置缓存的时间
        //




    
    
    </script>
</body>
</html>